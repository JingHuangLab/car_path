# Integrated test for Muller Potential. 
# Zilin Song, 5 Jul 2022
# 

# Generic Python.
from io import TextIOWrapper
import sys, os
sys.dont_write_bytecode = True
sys.path.insert(0, os.getcwd())
from typing import Type, List

# PyCoSPath
from pycospath.cos import   ConstAdvRep          as CAR,   \
                            ConstAdvRepParamTan  as carpt, \
                            StringMethod         as sm,    \
                            StringMethodGradProj as smgp,  \
                            CosBase

from pycospath.chain import Chain2D
from pycospath.comms.twodim import Rep2D, PotMuller
from pycospath.opt import ConsGradientDescent

# Misc.
import numpy
import matplotlib.pyplot as plt
from matplotlib.axes import Axes
import seaborn as sns

def exec_cos(cosname: str,
             n_reps:  int,
             n_steps: int, 
             cons_log_writer: TextIOWrapper = None, 
             cons_curvreglr_thresh=30,
             cons_maxitr=10, 
             cons_thresh=1e-8, 
             cons_stepreglr_thresh=1.25,
             gd_eta=.01):
    """Execute the cos descent and record the descending trajectories. """

    # Initialize cos optimization. 
    pot = PotMuller()

    ## Linear interception between (0, 0) and (0, 2)
    xs = numpy.zeros((n_reps, ))
    ys = numpy.linspace(0., 2., num=n_reps)

    ## Make a list of Replicas. 
    rep_list = []

    for i_rep in range(n_reps):
        coor = numpy.asarray([xs[i_rep], ys[i_rep]])
        rep = Rep2D(coor, pot)
        rep_list.append(rep)

    chain = Chain2D(rep_list)

    cos = CAR(  chain, verbose=True, cons_thresh=cons_thresh, cons_maxitr=cons_maxitr, cons_stepreglr_thresh=cons_stepreglr_thresh, 
                cons_curvreglr_thresh=cons_curvreglr_thresh, cons_log_writer=cons_log_writer) if cosname=='car' else \
          carpt(chain, verbose=True, cons_thresh=cons_thresh, cons_maxitr=cons_maxitr, cons_stepreglr_thresh=cons_stepreglr_thresh, 
                cons_curvreglr_thresh=cons_curvreglr_thresh, cons_log_writer=cons_log_writer) if cosname=='carpt' else \
          sm(chain) if cosname=='sm' else smgp(chain)

    opt = ConsGradientDescent(cos, gd_eta=gd_eta)

    # Initial chain_vec
    init_cvec = chain.get_chain_vec()


    # Evolve the cos and record the chain_vec per step. 
    for _ in range(n_steps):
        print(_, flush=True)
        opt.step()

    # Final chain_vec
    finl_cvec = chain.get_chain_vec()
    ener = chain.get_eners_grads()[0]
    print(ener)

    return init_cvec, finl_cvec, ener

# def plot_cvec(ax: Axes, 
#               init: numpy.ndarray, 
#               finl: numpy.ndarray, 
#               s: float) -> Axes:
#     """Plot the cos calculations. """
#     # Plot Muller PES
#     pot = PotMuller()
#     x, y, v = pot.get_pes()

#     v = ax.contourf(x, y, v, 200, extend='both')

#     # Plot init cvec. 
#     ax.scatter(init[:, 0], init[:, 1], s=2, color=sns.color_palette('colorblind')[6], zorder=5)
    
#     # Plot final cvec.
#     ax.scatter(finl[:, 0], finl[:, 1], s=2, color=sns.color_palette('colorblind')[1], zorder=5)
    
#     # Ticks and scale.
#     ax.xaxis.set_ticks([-1.5, -.8, -.1,  .6, 1.3])
#     ax.yaxis.set_ticks([-.5,   .2,  .9, 1.6, 2.3])
#     ax.set_xlim(-1.5, 1.3)
#     ax.set_ylim(-0.5, 2.3)
    
#     ax.tick_params(top=True, right=True, direction='in', width=1.5, length=4, labelsize=12)
#     ax.spines['left'].set_linewidth(1.5)
#     ax.spines['right'].set_linewidth(1.5)
#     ax.spines['top'].set_linewidth(1.5)
#     ax.spines['bottom'].set_linewidth(1.5)
#     ax.set_aspect('equal', adjustable='box')
    
#     return ax, v

if __name__ == "__main__":
    mode = sys.argv[1]

    if mode == '0':
        out_car_high_con_thresh   = exec_cos('car',   25, 300, 
                                            cons_log_writer=open('./ms0_car/fig_exploit/high_cons_thresh/car.log', 'w'), 
                                            cons_thresh=1e-15, cons_curvreglr_thresh=30)
                                    # numpy.load('./ms0_car/fig_exploit/high_cons_thresh/car_cvec.npy')
        numpy.save('./ms0_car/fig_exploit/high_cons_thresh/car_cvec.npy', out_car_high_con_thresh[:2])

        out_carpt_high_con_thresh = exec_cos('carpt', 25, 300, 
                                             cons_log_writer=open('./ms0_car/fig_exploit/high_cons_thresh/carpt.log', 'w'), 
                                             cons_thresh=1e-15, cons_curvreglr_thresh=30)
                                    # numpy.load('./ms0_car/fig_exploit/high_cons_thresh/carpt_cvec.npy')
        numpy.save('./ms0_car/fig_exploit/high_cons_thresh/carpt_cvec.npy', out_carpt_high_con_thresh[:2])


    elif mode == '1':
        out_car_dense_rep         = exec_cos('car',  1000, 300, 
                                             cons_log_writer=open('./ms0_car/fig_exploit/dense_rep/car.log', 'w'), 
                                             cons_curvreglr_thresh=10, cons_maxitr=500, gd_eta=.005)
                                    # numpy.load('./ms0_car/fig_exploit/dense_rep/car_cvec.npy')

        numpy.save('./ms0_car/fig_exploit/dense_rep/car_cvec.npy', out_car_dense_rep[:2])


    elif mode == '2':
        out_carpt_dense_rep       =  exec_cos('carpt', 1000, 300, 
                                              cons_log_writer=open('./ms0_car/fig_exploit/dense_rep/carpt.log', 'w'), 
                                              cons_curvreglr_thresh=10, cons_maxitr=500, gd_eta=.005)
        # numpy.load('./ms0_car/fig_exploit/dense_rep/carpt_cvec.npy')

        numpy.save('./ms0_car/fig_exploit/dense_rep/carpt_cvec.npy', out_carpt_dense_rep[:2])


    elif mode == '3':
        out_sm_dense_rep    = exec_cos('sm'   , 1000, 300, gd_eta=.005) #  numpy.load('./ms0_car/fig_exploit/dense_rep/sm_cvec.npy')  
        out_smgp_dense_rep  = exec_cos('smgp' , 1000, 300, gd_eta=.005) #  numpy.load('./ms0_car/fig_exploit/dense_rep/smgp_cvec.npy')

        numpy.save('./ms0_car/fig_exploit/dense_rep/sm_cvec.npy', out_sm_dense_rep[:2])

        numpy.save('./ms0_car/fig_exploit/dense_rep/smgp_cvec.npy', out_smgp_dense_rep[:2])
